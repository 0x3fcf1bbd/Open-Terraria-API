/*
Copyright (C) 2020 DeathCradle

This file is part of Open Terraria API v3 (OTAPI)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.CodeAnalysis.Text;
using OTAPI;
using OTAPI.Mods.Relinker;
using System;
using System.IO;
using System.Linq;
using System.Reflection;

namespace CSharpScript
{
    [OTAPI.Modification(OTAPI.ModType.Read, "Loading CSharpScript interface")]
    public class CSharpScript
    {
        public MonoMod.MonoModder Modder { get; set; }

        public CSharpScript(MonoMod.MonoModder modder)
        {
            Modder = modder;

            System.Console.WriteLine($"[CSS] Starting runtime");
            RunModules();
        }

        void RunModules()
        {
            var path = Path.Combine("csharp", "modifications");
            var outDir = Path.Combine("csharp", "generated");
            if (Directory.Exists(path))
            {
                if (Directory.Exists(outDir)) Directory.Delete(outDir, true);
                Directory.CreateDirectory(outDir);

                var constants = File.ReadAllText("../../../../OTAPI.Setup/bin/Debug/net5.0/AutoGenerated.cs"); // bring across the generated 

                foreach (var file in Directory.EnumerateFiles(path, "*.cs", SearchOption.AllDirectories))
                {
                    System.Console.WriteLine($"[CSS] Loading module: {file}");
                    try
                    {
                        var contents = constants + "\nusing System;\nusing OTAPI;\nusing MonoMod;\nusing OTAPI.Mods.Relinker; " + File.ReadAllText(file);

                        var codeString = SourceText.From(contents);
                        var options = CSharpParseOptions.Default.WithLanguageVersion(LanguageVersion.Preview); // allows toplevel functions

                        var parsedSyntaxTree = SyntaxFactory.ParseSyntaxTree(codeString, options);

                        using var dllStream = new MemoryStream();

                        var assemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location);
                        EmitResult Compile(bool dll)
                        {
                            var compilation = CSharpCompilation.Create($"CSharpScript_{Guid.NewGuid()}", new[] { parsedSyntaxTree }, new[]
                            {
                                MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "System.Private.CoreLib.dll")),
                                MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "System.Console.dll")),
                                MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "System.Runtime.dll")),
                                MetadataReference.CreateFromFile(typeof(OTAPI.ModType).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(IRelinkProvider).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(MonoMod.MonoModder).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(Terraria.WindowsLaunch).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(On.Terraria.WindowsLaunch).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(System.Runtime.InteropServices.RuntimeInformation).Assembly.Location)
                            }.Concat(typeof(MonoMod.MonoModder).Assembly.GetReferencedAssemblies().Select(asm => MetadataReference.CreateFromFile(Assembly.Load(asm).Location))));

                            if (dll)
                            {
                                compilation = compilation.WithOptions(new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
                            }

                            return compilation.Emit(dllStream);
                        }

                        var compilationResult = Compile(false);

                        if (!compilationResult.Success)
                        {
                            compilationResult = Compile(true); // usually a monomod patch
                        }

                        if (compilationResult.Success)
                        {
                            // save the file for monomod (doesnt like streams it seems?)
                            // then register the reflected assembly, then the monomod variant for patches

                            dllStream.Seek(0, SeekOrigin.Begin);

                            var asm = OTAPI.Plugins.PluginLoader.AssemblyLoader.Load(dllStream);

                            var outPath = Path.Combine(outDir, $"{asm.GetName().Name}.dll");
                            var data = dllStream.ToArray();
                            File.WriteAllBytes(outPath, data);

                            OTAPI.Plugins.PluginLoader.AddAssembly(asm);
                            Modder.ReadMod(outPath);
                        }
                        else
                        {
                            Console.WriteLine("Compilation done with error.");

                            var failures = compilationResult.Diagnostics.Where(diagnostic => diagnostic.IsWarningAsError || diagnostic.Severity == DiagnosticSeverity.Error);

                            foreach (var diagnostic in failures)
                            {
                                Console.Error.WriteLine("{0}: {1}", diagnostic.Id, diagnostic.GetMessage());
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        System.Console.WriteLine($"[CSS] Load error: {ex}");
                    }
                }
            }
        }
    }
}
