using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.CodeAnalysis.Scripting;
using Microsoft.CodeAnalysis.Text;
using ModFramework.Plugins;
using ModFramework.Relinker;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace ModFramework.Modules
{
    [MonoMod.MonoModIgnore]
    [Modification(ModType.Read, "Loading CSharpScript interface")]
    public class ModulePlugin
    {
        const string ConsolePrefix = "CSharp";
        const string ModulePrefix = "CSharpScript_";
        public MonoMod.MonoModder Modder { get; set; }

        public ModulePlugin(MonoMod.MonoModder modder)
        {
            Modder = modder;

            Console.WriteLine($"[{ConsolePrefix}] Starting runtime");

            modder.OnReadMod += (m, module) =>
            {
                if (module.Assembly.Name.Name.StartsWith(ModulePrefix))
                {
                    // remove the top level program class
                    var tlc = module.GetType("<Program>$");
                    if (tlc != null)
                    {
                        module.Types.Remove(tlc);
                    }
                    Modder.RelinkAssembly(module);
                }
            };

            RunModules();
        }

        IEnumerable<MetadataReference> LoadExternalRefs(string path)
        {
            var refs = System.IO.File.ReadLines(Path.Combine(path, "Metadata.refs"));

            var assemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location);

            foreach (var ref_file in refs)
            {
                var sys_path = Path.Combine(assemblyPath, ref_file);

                if (File.Exists(ref_file))
                    yield return MetadataReference.CreateFromFile(ref_file);

                else if (File.Exists(sys_path))
                    yield return MetadataReference.CreateFromFile(sys_path);

                else throw new Exception($"Unable to resolve external reference: {ref_file} (Metadata.refs) in dir {Environment.CurrentDirectory}");
            }
        }

        void RunModules()
        {
            var path = Path.Combine("csharp", "modifications");
            var outDir = Path.Combine("csharp", "generated");
            if (Directory.Exists(path))
            {
                if (Directory.Exists(outDir)) Directory.Delete(outDir, true);
                Directory.CreateDirectory(outDir);

                var constants = File.ReadAllText("../../../../OTAPI.Setup/bin/Debug/net5.0/AutoGenerated.cs"); // bring across the generated constants

                foreach (var file in Directory.EnumerateFiles(path, "*.cs", SearchOption.AllDirectories))
                {
                    Console.WriteLine($"[{ConsolePrefix}] Loading module: {file}");
                    try
                    {
                        var encoding = System.Text.Encoding.UTF8;
                        var options = CSharpParseOptions.Default
                               .WithLanguageVersion(LanguageVersion.Preview); // allows toplevel functions

                        SyntaxTree encoded;
                        SourceText source;
                        using (var stream = File.OpenRead(file))
                        {
                            source = SourceText.From(stream, encoding, canBeEmbedded: true);
                            encoded = CSharpSyntaxTree.ParseText(source, options, file);
                        }

                        using var dllStream = new MemoryStream();
                        using var pdbStream = new MemoryStream();
                        using var xmlStream = new MemoryStream();

                        var assemblyName = $"{ModulePrefix}{Guid.NewGuid():N}";

                        var outAsmPath = Path.Combine(outDir, $"{assemblyName}.dll");
                        var outPdbPath = Path.Combine(outDir, $"{assemblyName}.pdb");

                        var assemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location);

                        EmitResult Compile(bool dll)
                        {
                            var refs = LoadExternalRefs(path).ToArray();

                            var compilation = CSharpCompilation.Create(assemblyName, new[] { encoded }, new MetadataReference[]
                            {
                                // runtime refs
                                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                                MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "System.Runtime.dll")),

                                // global refs
                                MetadataReference.CreateFromFile(typeof(ModType).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(Mono.Cecil.AssemblyDefinition).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(Mono.Cecil.Rocks.ILParser).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(Newtonsoft.Json.JsonConvert).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(MonoMod.MonoModder).Assembly.Location),
                            }
                                .Concat(typeof(MonoMod.MonoModder).Assembly.GetReferencedAssemblies()
                                .Select(asm => MetadataReference.CreateFromFile(Assembly.Load(asm).Location)))
                                .Concat(refs)
                            );

                            if (dll)
                            {
                                compilation = compilation
                                    .WithOptions(new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)
                                    .WithOptimizationLevel(OptimizationLevel.Debug)
                                    .WithPlatform(Platform.AnyCpu));
                            }

                            var emitOptions = new EmitOptions(
                                    debugInformationFormat: DebugInformationFormat.PortablePdb,
                                    pdbFilePath: outPdbPath);

                            var embeddedTexts = new List<EmbeddedText>
                            {
                                EmbeddedText.FromSource(file, source),
                            };

                            EmitResult result = compilation.Emit(
                                peStream: dllStream,
                                pdbStream: pdbStream,
                                embeddedTexts: embeddedTexts,
                                options: emitOptions);

                            return result;
                        }

                        var compilationResult = Compile(false);

                        if (!compilationResult.Success)
                        {
                            compilationResult = Compile(true); // usually a monomod patch
                        }

                        if (compilationResult.Success)
                        {
                            // save the file for monomod (doesnt like streams it seems?)
                            // then register the reflected assembly, then the monomod variant for patches

                            dllStream.Seek(0, SeekOrigin.Begin);
                            pdbStream.Seek(0, SeekOrigin.Begin);

                            var asm = PluginLoader.AssemblyLoader.Load(dllStream, pdbStream);
                            PluginLoader.AddAssembly(asm);

                            File.WriteAllBytes(outAsmPath, dllStream.ToArray());
                            File.WriteAllBytes(outPdbPath, pdbStream.ToArray());

                            Modder.ReadMod(outAsmPath);
                        }
                        else
                        {
                            //Console.WriteLine($"Compilation errors for file: {Path.GetFileName(file)}");

                            foreach (var diagnostic in compilationResult.Diagnostics.Where(diagnostic => diagnostic.IsWarningAsError || diagnostic.Severity == DiagnosticSeverity.Error))
                            {
                                Console.Error.WriteLine("{0}: {1}", diagnostic.Id, diagnostic.GetMessage());
                            }

                            throw new Exception($"Compilation errors above for file: {Path.GetFileName(file)}");
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[{ConsolePrefix}] Load error: {ex}");
                        throw;
                    }
                }
            }
        }
    }
}
