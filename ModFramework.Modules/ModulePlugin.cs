using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.CodeAnalysis.Text;
using ModFramework.Plugins;
using ModFramework.Relinker;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace ModFramework.Modules
{
    [Modification(ModType.Read, "Loading CSharpScript interface")]
    public class ModulePlugin
    {
        const string ModulePrefix = "CSharpScript_";
        public MonoMod.MonoModder Modder { get; set; }

        public ModulePlugin(MonoMod.MonoModder modder)
        {
            Modder = modder;

            Console.WriteLine("[CSS] Starting runtime");

            modder.OnReadMod += (m, module) =>
            {
                if (module.Assembly.Name.Name.StartsWith(ModulePrefix))
                {
                    // remove the program class
                    module.Types.Remove(module.GetType("$Program"));
                    Modder.RelinkModuleMap[module.Assembly.Name.Name] = modder.Module;
                }
            };

            RunModules();
        }

        void RunModules()
        {
            var path = Path.Combine("csharp", "modifications");
            var outDir = Path.Combine("csharp", "generated");
            if (Directory.Exists(path))
            {
                if (Directory.Exists(outDir)) Directory.Delete(outDir, true);
                Directory.CreateDirectory(outDir);

                var constants = File.ReadAllText("../../../../OTAPI.Setup/bin/Debug/net5.0/AutoGenerated.cs"); // bring across the generated 

                foreach (var file in Directory.EnumerateFiles(path, "*.cs", SearchOption.AllDirectories))
                {
                    Console.WriteLine($"[CSS] Loading module: {file}");
                    try
                    {
                        var contents = string.Join(Environment.NewLine, new []
                        {
                            constants,
                            "using System;",
                            "using ModFramework;",
                            "using MonoMod;",
                            "using ModFramework.Relinker;",
                            File.ReadAllText(file),
                        });

                        var codeString = SourceText.From(contents);
                        var options = CSharpParseOptions.Default.WithLanguageVersion(LanguageVersion.Preview); // allows toplevel functions

                        var parsedSyntaxTree = SyntaxFactory.ParseSyntaxTree(codeString, options);

                        using var dllStream = new MemoryStream();

                        var assemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location);
                        EmitResult Compile(bool dll)
                        {
                            var compilation = CSharpCompilation.Create($"{ModulePrefix}{Guid.NewGuid():N}", new[] { parsedSyntaxTree }, new[]
                            {
                                MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "System.Private.CoreLib.dll")),
                                MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "System.Console.dll")),
                                MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "System.Runtime.dll")),
                                MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "System.Collections.dll")),
                                MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "System.Linq.dll")),
                                MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "System.Linq.Expressions.dll")),
                                MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "mscorlib.dll")),
                                MetadataReference.CreateFromFile(typeof(ModType).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(Mono.Cecil.AssemblyDefinition).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(Newtonsoft.Json.JsonConvert).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(IRelinkProvider).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(MonoMod.MonoModder).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(Terraria.WindowsLaunch).Assembly.Location),
                                //MetadataReference.CreateFromFile(typeof(On.Terraria.WindowsLaunch).Assembly.Location),
                                MetadataReference.CreateFromFile(typeof(System.Runtime.InteropServices.RuntimeInformation).Assembly.Location)
                            }.Concat(typeof(MonoMod.MonoModder).Assembly.GetReferencedAssemblies().Select(asm => MetadataReference.CreateFromFile(Assembly.Load(asm).Location))));

                            if (dll)
                            {
                                compilation = compilation.WithOptions(new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
                            }

                            return compilation.Emit(dllStream);
                        }

                        var compilationResult = Compile(false);

                        if (!compilationResult.Success)
                        {
                            compilationResult = Compile(true); // usually a monomod patch
                        }

                        if (compilationResult.Success)
                        {
                            // save the file for monomod (doesnt like streams it seems?)
                            // then register the reflected assembly, then the monomod variant for patches

                            dllStream.Seek(0, SeekOrigin.Begin);

                            var asm = PluginLoader.AssemblyLoader.Load(dllStream);
                            PluginLoader.AddAssembly(asm);

                            var outPath = Path.Combine(outDir, $"{asm.GetName().Name}.dll");
                            var data = dllStream.ToArray();
                            File.WriteAllBytes(outPath, data);

                            Modder.ReadMod(outPath);

                            //Modder.Mods.Single(m => m is Mono.Cecil.AssemblyDefinition asm && asm.FullName == outDir)

                            //Modder.RelinkModuleMap[from] = Modder.Module;
                        }
                        else
                        {
                            Console.WriteLine($"Compilation errors for file: {Path.GetFileName(file)}");

                            foreach (var diagnostic in compilationResult.Diagnostics.Where(diagnostic => diagnostic.IsWarningAsError || diagnostic.Severity == DiagnosticSeverity.Error))
                            {
                                Console.Error.WriteLine("{0}: {1}", diagnostic.Id, diagnostic.GetMessage());
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[CSS] Load error: {ex}");
                    }
                }
            }
        }
    }
}
