using ModFramework;
using ModFramework.Modules.CSharp;
using ModFramework.Relinker;
using Mono.Cecil;
using System;
using System.IO;
using System.Linq;
using static ModFramework.ModContext;

namespace OTAPI.Patcher.Targets;

[MonoMod.MonoModIgnore]
public static class ServerPatchExtensions
{
    public static void CreateRuntimeHooks(this ModFwModder modder, string output)
    {
        modder.Log("[OTAPI] Generating OTAPI.Runtime.dll");
        var gen = new MonoMod.RuntimeDetour.HookGen.HookGenerator(modder, "OTAPI.Runtime.dll");
        using var srm = new MemoryStream();
        using (ModuleDefinition mOut = gen.OutputModule)
        {
            gen.Generate();

            mOut.Write(srm);
        }

        srm.Position = 0;
        var fileName = Path.GetFileName(output);
        using var mm = new ModFwModder(new("OTAPI.Runtime"))
        {
            Input = srm,
            OutputPath = output,
            MissingDependencyThrow = false,
            //LogVerboseEnabled = true,
            // PublicEverything = true, // this is done in setup

            GACPaths = new string[] { } // avoid MonoMod looking up the GAC, which causes an exception on .netcore
        };
        mm.Log($"[OTAPI] Processing corelibs to be net6: {fileName}");

        mm.Read();

        mm.AddTask<CoreLibRelinker>();

        mm.MapDependencies();
        mm.AutoPatch();

        mm.Write();
    }

    public static void AddConstants(this IModPatchTarget target, string inputName, ModFwModder modder)
    {
        var version = modder.Module.Assembly.Name.Version;
        var const_major = $"{inputName}_V{version.Major}_{version.Minor}";
        var const_fullname = $"{inputName}_{version.ToString().Replace(".", "_")}";
        var const_senddatapatch = $"{inputName}_SendDataNumber{(version == new Version("1.4.3.0") ? "8" : "7")}";
        var const_entitysource = $"{inputName}_EntitySources{(version >= new Version("1.4.3.3") ? "Active" : "Inactive")}";

        File.WriteAllText("AutoGenerated.target", @$"<!-- DO NOT EDIT THIS FILE! It was auto generated by the setup project  -->
<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
  <PropertyGroup>
    <DefineConstants>{inputName};{const_major};{const_fullname};{const_senddatapatch};{const_entitysource}</DefineConstants>
  </PropertyGroup>
</Project>");
        target.ModContext.ReferenceConstants.AddRange(new[]
        {
            $"#define {inputName}",
            $"#define {const_major}",
            $"#define {const_fullname}",
            $"#define {const_senddatapatch}",
            $"#define {const_entitysource}",
        });
    }

    public static string Patch(this IModPatchTarget target, string status, string input, string output, bool publicEverything,
        Func<ModType, ModFwModder?, EApplyResult> onApplying,
        Action<ModFwModder, string>? print = null
    )
    {
        if (print is null) print = (_, str) => Console.WriteLine(str);

        EApplyResult OnApplying(ModType modType, ModFwModder? modder)
        {
            return onApplying(modType, modder);
        };

        target.ModContext.OnApply += OnApplying;
        try
        {
            using ModFwModder mm = new(target.ModContext)
            {
                InputPath = input,
                OutputPath = output,
                MissingDependencyThrow = false,
                PublicEverything = publicEverything,

                LogVerboseEnabled = true,

                GACPaths = new string[] { }, // avoid MonoMod looking up the GAC, which causes an exception on .netcore

                MarkdownDocumentor = target.MarkdownDocumentor,

                //EnableWriteEvents = writeEvents,
            };

            target.AddSearchDirectories(mm);
            mm.AddTask<CoreLibRelinker>();

            mm.Read();

            print(mm, $"[OTAPI] Mapping dependencies: {status}");
            mm.MapDependencies();

            print(mm, $"[OTAPI] Patching: {status}");
            mm.AutoPatch();

            print(mm, $"[OTAPI] Writing: {status}, Path={mm.OutputPath}");
            mm.WriterParameters.SymbolWriterProvider = null;
            mm.WriterParameters.WriteSymbols = false;
            mm.Write();

            return mm.OutputPath;
        }
        finally
        {
            target.ModContext.OnApply -= OnApplying;
        }
    }
}
