/*
Copyright (C) 2020 DeathCradle

This file is part of Open Terraria API v3 (OTAPI)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
using System;
using System.IO;
using System.Linq;
using System.Net.Http;
using ModFramework;
using ModFramework.Plugins;
using ModFramework.Relinker;
using Mono.Cecil;

namespace OTAPI.Setup.Targets
{
    [MonoMod.MonoModIgnore]
    public class VanillaServerPatchTarget : IPatchTarget
    {
        const String TerrariaWebsite = "https://terraria.org";

        public string DisplayText { get; } = "Vanilla Server";

        public void Patch()
        {
            var input = DownloadServer();

            Console.WriteLine("[OTAPI] Extracting embedded binaries and packing into one binary...");

            // allow for refs to the embedded resources, such as ReLogic.dll
            var extractor = new ResourceExtractor();
            var embeddedResourcesDir = extractor.Extract(input);
            var inputName = Path.GetFileNameWithoutExtension(input);

            Directory.CreateDirectory("outputs");

            var output = Path.Combine("outputs", "TerrariaServer.dll");

            using ModFwModder mm = new ModFwModder()
            {
                InputPath = input,
                OutputPath = output,
                ReadingMode = ReadingMode.Deferred,
                MissingDependencyThrow = false,
                PublicEverything = true, // we want all of terraria exposed

                LogVerboseEnabled = false,

                GACPaths = new string[] { } // avoid MonoMod looking up the GAC, which causes an exception on .netcore
            };
            (mm.AssemblyResolver as DefaultAssemblyResolver)!.AddSearchDirectory(embeddedResourcesDir);
            mm.Read();


            var initialModuleName = mm.Module.Name;

            // prechange the assembly name to a dll
            // monomod will also reference this when relinking so it must be correct
            // in order for shims within this dll to work (relogic)
            mm.Module.Name = "TerrariaServer.dll";
            mm.Module.Assembly.Name.Name = "TerrariaServer";

            foreach (var path in new[] {
                Path.Combine(System.Environment.CurrentDirectory, "TerrariaServer.OTAPI.Shims.mm.dll"),
                //Path.Combine(System.Environment.CurrentDirectory, "ModFramework.dll"),
                Directory.GetFiles(embeddedResourcesDir).Single(x => Path.GetFileName(x).Equals("ReLogic.dll", StringComparison.CurrentCultureIgnoreCase)),
                Directory.GetFiles(embeddedResourcesDir).Single(x => Path.GetFileName(x).Equals("Steamworks.NET.dll", StringComparison.CurrentCultureIgnoreCase)),
            })
            {
                mm.ReadMod(path);
            }

            // add the SourceAssembly name attribute
            {
                var sac = mm.Module.ImportReference(typeof(SourceAssemblyAttribute).GetConstructor(Type.EmptyTypes));
                var sa = new CustomAttribute(sac);
                sa.Fields.Add(new CustomAttributeNamedArgument("ModuleName", new CustomAttributeArgument(mm.Module.TypeSystem.String, initialModuleName)));
                sa.Fields.Add(new CustomAttributeNamedArgument("FileName", new CustomAttributeArgument(mm.Module.TypeSystem.String, inputName)));
                mm.Module.Assembly.CustomAttributes.Add(sa);
            }

            mm.MapDependencies();
            mm.AddTask(new CoreLibRelinker());
            mm.AutoPatch();

            //mm.OutputPath = mm.Module.Name; // the merged TerrariaServer + ReLogic (so we can apply patches)

            // switch to any cpu so that we can compile and use types in mods
            // this is usually in a modification otherwise
            mm.Module.Architecture = TargetArchitecture.I386;
            mm.Module.Attributes = ModuleAttributes.ILOnly;

            Console.WriteLine($"[OTAPI] Saving {mm.OutputPath}");
            mm.Write();

            var const_major = $"{inputName}_V{mm.Module.Assembly.Name.Version.Major}_{mm.Module.Assembly.Name.Version.Minor}";
            var const_fullname = $"{inputName}_{mm.Module.Assembly.Name.Version.ToString().Replace(".", "_")}";

            File.WriteAllText("AutoGenerated.target", @$"<!-- DO NOT EDIT THIS FILE! It was auto generated by the setup project  -->
<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
  <PropertyGroup>
    <DefineConstants>{inputName};{const_major};{const_fullname}</DefineConstants>
  </PropertyGroup>
</Project>");
            File.WriteAllText("AutoGenerated.cs", @$"#define {inputName}
#define {const_major}
#define {const_fullname}
");

            PluginLoader.Clear();

            //// convert the libary to net5
            //CoreLibRelinker.PostProcessCoreLib(mm.OutputPath);
            var dest = Path.GetFileName(output);
            if (File.Exists(dest)) File.Delete(dest);
            File.Copy(output, dest);
        }

        public string DownloadServer()
        {
            var zipUrl = GetZipUrl();
            var zipPath = Remote.DownloadZip(zipUrl);
            var extracted = Remote.ExtractZip(zipPath);

            return DetermineInputAssembly(extracted);
        }

        public string AquireLatestBinaryUrl()
        {
            this.Log("Determining the latest TerrariaServer.exe...");
            using var client = new HttpClient();

            var data = client.GetByteArrayAsync(TerrariaWebsite).Result;
            var html = System.Text.Encoding.UTF8.GetString(data);

            const String Lookup = ">PC Dedicated Server";

            var offset = html.IndexOf(Lookup, StringComparison.CurrentCultureIgnoreCase);
            if (offset == -1) throw new NotSupportedException();

            var attr_character = html[offset - 1];

            var url = html.Substring(0, offset - 1);
            var url_begin_offset = url.LastIndexOf(attr_character);
            if (url_begin_offset == -1) throw new NotSupportedException();

            url = url.Remove(0, url_begin_offset + 1);

            return TerrariaWebsite + url;
        }

        public string DetermineInputAssembly(string extractedFolder)
        {
            return Directory.EnumerateFiles(extractedFolder, "TerrariaServer.exe", SearchOption.AllDirectories).Single(x =>
                Path.GetFileName(Path.GetDirectoryName(x)).Equals("Windows", StringComparison.CurrentCultureIgnoreCase)
            );
        }

        public string GetZipUrl()
        {
            var cli = this.GetCliValue("latestVanilla");

            if (cli != "n")
            {
                int attempts = 5;
                do
                {
                    Console.Write("Download the latest binary? y/[N]: ");

                    var input = Console.ReadLine().ToLower();

                    if (input.Equals("y", StringComparison.CurrentCultureIgnoreCase))
                        return AquireLatestBinaryUrl();
                    else if (input.Equals("n", StringComparison.CurrentCultureIgnoreCase))
                        break;

                    if (String.IsNullOrWhiteSpace(input)) // no key entered
                        break;

                } while (attempts-- > 0);
            }

            return "https://terraria.org/system/dedicated_servers/archives/000/000/046/original/terraria-server-1423.zip";
        }
    }
}
